---

- name: find out uuid for target devices for fstab / crypttab
  command: "lsblk -nJ -o NAME,UUID,PARTUUID {{ _tgt_devices.keys()|join(' ') }}"
  register: _lsblk

- set_fact:
    _tmp: '{{ _lsblk.stdout|from_json }}'

- name: add uuid to _tgt_devices
  set_fact:
    _tgt_devices: >
      {{ _tgt_devices|combine({'/dev/' + item.name: _tgt_devices['/dev/'+ item.name]|default({})|combine({'uuid': item.uuid })}) }}
  with_items: "{{ _tmp['blockdevices'] }}"
  when: item.uuid is defined and _tgt_devices['/dev/' + item.name] is defined

- name: add uuid to _tgt_devices (device mapper)
  set_fact:
    _tgt_devices: >
      {{ _tgt_devices|combine({'/dev/mapper/' + item.name: _tgt_devices['/dev/mapper/'+ item.name]|default({})|combine({'uuid': item.uuid })}) }}
  with_items: "{{ _tmp['blockdevices'] }}"
  when: item.uuid is defined and _tgt_devices['/dev/mapper/' + item.name] is defined

- name: Set the hostname
  copy:
    dest: "{{ _tgt_root }}/etc/hostname"
    content: "{{ fqdn.split('.')[0] }}"
    mode: 0o644

- name: Configure additional hosts
  ansible.builtin.lineinfile:
    path: "{{ _tgt_root }}/etc/hosts"
    insertafter: '^127.0.0.1'
    line: "{{ item }}"
  loop: "{{ etchosts }}"

- name: Instantiate templates to /etc
  template:
    src: "{{ item.src }}"
    dest: "{{ _tgt_root }}/etc/{{ item.dest | default(item.src) }}"
    owner: "{{ item.owner|default('root') }}"
    group: "{{ item.group|default('root') }}"
    mode: "{{ item.mode|default('0644') }}"
  with_items:
  - { src: 'crypttab', dest: 'crypttab' }
  - { src: 'interfaces', dest: 'network/interfaces' }
  - { src: 'resolv.conf', dest: 'resolv.conf' }

- name: Configure basic mountpoints
  mount:
    fstype: "{{ item.value['fs'] }}"
    opts: "{{ item.value['mountopts'] | default('defaults') }}"
    path: "{{ item.value['mount'] }}"
    src: "{{ 'UUID='+item.value['uuid']  | default(item.key) }}"
    fstab: "{{ _tgt_root }}/etc/fstab"
    state: present
  when:
    - "not (item.value['encrypt'] | default(False))"
    - "not item.value['fs'] == 'zfs_member'"
    - "'mount' in item.value"
  loop: "{{ _tgt_devices|dict2items }}"

- name: Configure NFS
  mount:
    fstype: nfs
    opts: defaults
    path: "{{ nfs_mountroot }}/{{ item.1 }}"
    src: "{{ item.0.address }}/{{ item.1 }}"
    fstab: "{{ _tgt_root }}/etc/fstab"
    state: present
  loop: "{{ nfs_servers|subelements('mounts') }}"

- name: Add thin provisoning hook
  copy:
    src: "lvm-thin"
    dest: "{{ _tgt_root }}/etc/initramfs-tools/hooks/lvm-thin"
    owner: root
    group: root
    mode: 0755
  when: lvm is defined

# In some configurations initramfstools will not correctly detect encrypted root, this
# forces cryptsetup to be included.
- name: enforce cryptsetup in initramfs
  copy:
    dest: "{{ _tgt_root }}/etc/initramfs-tools/conf.d/cryptsetup"
    content: "export CRYPTSETUP=y"
  when: _luksopen is defined and _luksopen.changed

- name: Ensure ZFS update rebuilds all initramfs
  copy:
    dest: "{{ _tgt_root }}/etc/dkms/zfs.conf"
    content: REMAKE_INITRD=yes
    mode: 0o644

- name: Set kexec to load
  replace:
    path: /etc/default/kexec
    regexp: '^LOAD_KEXEC=false,'
    replace: 'LOAD_KEXEC=true,'

- name: Copy zfs passphrase to file
  copy:
    dest: "{{ _tgt_root }}/etc/zfs/{{ item.poolname }}.key"
    content: "{{ item.passphrase }}"
    mode: '600'
  loop: "{{ zfs_pool }}"

- name: Change ZFS pool to look for key file
  command: >
    "zfs change-key -o keylocation=file:///etc/zfs{{ item.poolname }}.key -o keyformat=passphrase {{ item.poolname }}"
  loop: "{{ zfs_pool }}"

- name: Set zfs commandline
  command: 'zfs set org.zfsbootmenu:commandline="spl_hostid=\{{ _hostid.stdout }} ro quiet" {{ item.poolname }}/ROOT'

- name: git clone zfsbootmenu
  git:
    repo: https://github.com/zbm-dev/zfsbootmenu.git
    dest: {{ _tgt_root}}/root/zfsbootmenu

- name: Compile zfsbootmenu
  shell: "chroot {{ _tgt_root }} && cd /root/zfsbootmenu && make install"

- name: Configure zfsbootmenu
  copy:
    content: |
      Global:
        ManageImages: true
        BootMountPoint: /boot/efi
        DracutConfDir: /etc/zfsbootmenu/dracut.conf.d
      Components:
        ImageDir: /boot/efi/EFI/debian
        Versions: false
        Enabled: true
        syslinux:
          Config: /boot/syslinux/syslinux.cfg
          Enabled: false
      EFI:
        ImageDir: /boot/efi/EFI/debian
        Versions: false
        Enabled: false
      Kernel:
        CommandLine: ro quiet loglevel=0
    dest: "{{ _tgt_root }}/etc/zfsbootmenu/config.yaml"
    owner: root
    group: root
    mode: 0o644

- name: Omit systemd dracut modules to prevent ZBM boot breaking
  copy:
    content: |
      omit_dracutmodules+=" systemd systemd-initrd dracut-systemd "
    dest: "{{ _tgt_root }}/etc/zfsbootmenu/dracut.conf.d/zfsbootmenu.conf"
    owner: root
    group: root
    mode: 0o644

- name: Download & build Yaml PP Perl module
  command: "chroot {{ _tgt_root }} cpan 'YAML::PP'"

- name: Create key to sign kernel modules
  command: |
    chroot {{ _tgt_root }} openssl \
      req \
      -nodes \
      -new -x509 -newkey rsa:2048 \
      -keyout /root/mok.priv \
      -outform DER -out /root/mok.der \
      -days 36500 \
      -subj "/CN={{ fqdn }} module signing key/"
  args:
    creates: /root/mok.priv

- name: update initramfs
  command: "chroot {{ _tgt_root }} update-initramfs -c -k all"

- name: Generate ZFSBootMenu
  command: "chroot {{ _tgt_root }} generate-zbm"

- name: Create refind_linux.conf
  copy:
    content: |
      "Boot default"  "zfsbootmenu:POOL=$RPOOL zbm.import_policy=hostid zbm.set_hostid zbm.timeout=15 ro quiet loglevel=0"
      "Boot to menu"  "zfsbootmenu:POOL=$RPOOL zbm.import_policy=hostid zbm.set_hostid zbm.show ro quiet loglevel=0"
    dest: "{{ _tgt_root }}/boot/efi/EFI/debian/refind_linux.conf"
    owner: root
    group: root
    mode: 0o644

- name: set root password
  command: >
      chroot {{ _tgt_root }} usermod -p '{{ root_password }}' root
  when: root_password is defined
